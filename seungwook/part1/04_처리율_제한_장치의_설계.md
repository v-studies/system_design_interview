# 처리율 제한 장치의 설계

네트워크 시스템에서 처리율 제한 장치(rate limit)는 클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치다.

예를들어,

- 사용자는 초당 2회 이상 새 글을 올릴 수 없다.
- 같은 IP 주소로는 하루에 10개 이상의 계정을 생성할 수 없다.
- 같은 디바이스로는 주당 5회 이상 리워드를 요청할 수 없다.

## 처리율 제한 장치는 어디에 둘 것인가?

### 클라이언트

일반적으로 클라이언트 요청은 쉽게 위변조가 가능해 처리율 제한 장치를 클라이언트에 두는 것은 위험하다.

### 서버

![image](https://github.com/user-attachments/assets/e08d47b4-0230-4a15-ba43-3973d70ae3b6)


### 미들웨어

<img src="https://github.com/user-attachments/assets/1bffa3a8-96a0-4b51-bc2c-8d4b7b2b2e56" width="800">


처리율 제한 장치는 보통 API 게이트웨이라 불리는 컴포넌트에 구현된다.

<br>

## 처리율 제한 알고리즘

### 1) 토큰 버킷 알고리즘

토큰 버킷 알고리즘은 간단하고 알고리즘에 대한 세간의 이해도도 높은 편이여서 처리율 제한에 폭넓게 이용되고 있다.

아마존과 스트라이프가 API 요청을 통제하기 위해 이 알고리즘을 사용한다.

<img src="https://github.com/user-attachments/assets/1182ce38-5f3c-44cf-af1c-2490cda60ad0" width="500">

- 매초 토큰이 채워진다.
- 각 요청이 처리될때마다 토큰이 소비된다.
- 토큰이 없으면 요청을 거부한다.

#### 장점

- 구현이 쉽다.
- 메모리 사용 측면에서도 효율적이다.
- 짧은 시간에 집중되는 트래픽도 처리 가능하다.

#### 단점

- 버킷 크기와 토큰 공급률을 적절하게 튜닝하는것은 까다로운 일이다.




### 2) 누출 버킷 알고리즘

누출 버킷 알고리즘은 토큰 버킷 알고리즘과 비슷하지만 요청 처리율이 고정되어 있다는 점이 다르다.

보통 FIFO 큐를 사용하여 요청을 처리한다.

<img src="https://github.com/user-attachments/assets/be454633-9b39-418d-aa79-58e6fffea14b" width="800">

- 요청이 들어오면 빈자리가 있으면 큐에 추가한다.
- 큐가 가득 차면 요청을 거부한다.
- 지정된 시간마다 큐에서 요청을 꺼내어 처리한다.

#### 장점

- 큐의 크기가 제한되어 있어 메모리 사용량 측면에서 효율적이다.

#### 단점

- 단시간에 많은 트래픽이 몰리는 경우 큐에는 요청이 쌓이게 되고, 그 요청들을 제때 처리 못하면 최신 요청들은 버려지게 된다.





### 3) 고정 윈도 카운터 알고리즘

<img src="https://github.com/user-attachments/assets/42545a73-6475-475d-bba6-a45986a23bee" width="800">

- 타임라인을 고정된 간격의 윈도(window)로 나누고, 각 윈도마다 카운터 만큼만 받는다.
- 설정된 임계치에 도달하면 새로운 요청은 새 윈도가 열릴때까지 버려진다.

그러나 이 알고리즘의 가장 큰 문제는 윈도의 경계 부근에 순간적으로 많은 트래픽이 집중될 경우 윈도에 할당된 양보다 더 많은 요청이 처리될 수 있다는 것이다.

<img src="https://github.com/user-attachments/assets/d129542f-7e7c-489c-bab2-0ceae2dba2a0" width="800">

위의 예제는 분당 최대 5개의 요청만을 허용하는 시스템이다.

고정 윈도 카운터의 경계값 문제는 `2:00:59`에 5개의 요청이 들어오고, `2:01:00`에 다시 카운트가 초기화되어 추가 5개의 요청이 들어오면, 짧은 시간에 총 10개를 처리하게 된다.

#### 장점

- 메모리 효율이 좋다.
- 윈도가 닫히는 시점에 카운터를 초기화하는 방식은 특정한 트래픽 패턴을 처리하기에 적합하다.

#### 단점

- 윈도 경계 부근에서 일시적으로 많은 트래픽이 몰려드는 경우, 기대했던 처리 한도보다 많은 양을 처리하는 경우가 생긴다.

### 4) 이동 윈도 로깅 알고리즘

이동 윈도 로깅 알고리즘은 고정 윈도 카운터 알고리즘에 있는 문제를 해결할 수 있다.


<img src="https://github.com/user-attachments/assets/555b368d-63f4-441b-bd16-7e076812a16e" width="800">

- `1:00:01` 요청 : 로그는 비어 있는 상태 **(허용)**
- `1:00:30` 요청 : 추가 직후 로그의 크기는 2이며, 허용 한도보다 크지 않다. **(허용)**
- `1:00:50` 요청 : 이때 로그의 크기는 3이며, 허용 한도보다 크다. 따라서 타임스탬프는 로그에 남김 **(거부)**
- `1:01:40` 요청 : `1:00:40` 이전의 타임스탬프는 전부 만료된 값으로 삭제해주고 로그의 크기는 2로 줄어든다. **(허용)**

따라서 이동 윈도 로깅 알고리즘은 각 요청의 개별 타임스탬프를 기록하여, 요청이 특정 경계에 몰려도 과도한 요청을 허용하지 않도록 되어있다.

#### 장점

- 어느순간의 윈도를 보더라도, 허용되는 요청의 개수는 시스템의 처리율 한도를 넘지 않는다.

#### 단점

- 거부된 요청의 타임스탬프도 보관하기 때문에 다량의 메모리를 사용한다.


### 5) 이동 윈도 카운터 알고리즘

이동 윈도 카운터 알고리즘은 고정 윈도 카운터 알고리즘과 이동 윈도 로깅 알고리즘을 결합한 것이다.

<img src="https://github.com/user-attachments/assets/40e61664-386f-45fd-90be-1409c1f9ad7f" width="800">

- 현재 1분간의 요청 수 + 직전 1분간의 요청 수 X 이동 윈도와 직전 1분이 겹치는 비율 (3 + 5 x 70%) = 6.5

#### 장점

- 이전 시간대의 평균 처리율에 따라 현재 윈도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘 대응한다.
- 메모리 효율이 좋다.

#### 단점

- 직전 시간대에 도착한 요청이 균등하게 분포되어 있다고 가정
- 따라서 추정치를 계산하기 때문에 100% 정확하지는 않다.
- 하지만 클라우드플레어에서 수행한 실험에 의하면 0.003% 에 불과하다.

<br>

## 분산 환경에서의 처리율 제한 장치의 구현

여러 대의 서버와 병렬 스레드를 지원하도록 시스템을 확장하는 것은 다음 두 가지 어려운 문제를 풀어야 한다.

### 1) 경쟁 조건

경쟁 조건 이슈란, 두 개의 요청이 동시에 카운터를 가져가고 증가시키는 경우, 카운터가 5가 되어야하지만 4가 될 수 있다.

<img src="https://github.com/user-attachments/assets/afe9a7ec-6ca9-441a-be09-be9660983cd3" width="800">

경쟁 조건 문제를 해결하는 가장 널리 알려진 해결책은 락(lock)을 사용하는 것이다.

하지만 락은 시스템의 성능을 상당히 떨어뜨린다는 문제가 있다. 락 대신 쓸 수 있는 해결책이 두 가지가 있다.

- 루아 스크립트(Lua script)
- 정렬 집합(sorted set)


#### 루아 스크립트 (Lua Script)

Redis의 루아 스크립트를 사용하면, 여러 명령을 단일 스크립트로 결합하여 원자적으로 실행할 수 있다.

- **일반 카운터**
  - 단순히 GET으로 조회하고, 조건문에서 비교한 후 INCR로 증가하는 일련의 작업이 각각의 명령어로 실행된다.
  - 이 과정에서 여러 클라이언트가 동시에 접근하면, 조회와 증가 사이에 다른 요청이 개입할 수 있어 경쟁 조건이 발생할 수 있다.


- **루아 스크립트** 
  - 루아 스크립트를 사용하면 조회, 비교, 증가를 모두 묶어서 원자적 실행을 보장할 수 있다.


#### 정렬 집합 (Sorted Set)

정렬 집합(Sorted Set)을 사용하면, Redis가 제공하는 정렬된 자료 구조를 활용하여 경쟁 조건을 해결할 수 있습니다. 정렬 집합은 각 항목이 시간 순서대로 정렬되므로, 시간에 따른 요청 수를 정확히 추적할 수 있습니다.

- **일반 카운터**
    - 단순히 GET으로 조회하고, 조건문에서 비교한 후 INCR로 증가하는 일련의 작업이 각각의 명령어로 실행된다.
    - 이 과정에서 여러 클라이언트가 동시에 접근하면, 조회와 증가 사이에 다른 요청이 개입할 수 있어 경쟁 조건이 발생할 수 있다.


- **Sorted Set**:
  - 각 요청이 들어올 때마다 타임스탬프와 함께 추가되고, 만료된 요청을 원자적으로 삭제하는 과정에서 모든 명령이 원자적으로 수행되므로 경쟁 조건이 발생하지 않는다.


따라서, Redis의 루아 스크립트와 Sorted Set은 각 명령이 독립적이면서도 원자적으로 실행되기 때문에, 락을 사용하지 않고도 경쟁 조건을 해결할 수 있습니다.


### 2) 동기화

<img src="https://github.com/user-attachments/assets/320bb701-db4f-4e9d-95ef-30a83b4b8110" width="800">


수백만 사용자를 지원하려면 한 대의 처리율 제한 장치 서버로는 충분하지 않을 수 있다. 그래서 처리율 제한 장치 서버를 여러 대 두게 되면 동기화가 필요해진다.

이에 대한 한가지 해결책은 고정 세션(sticky session)을 활용하여 같은 클라이언트의 요청은 항상 같은 처리율 제한 장치로 보낼 수 있도록 하는것이다.

하지만 이 방법은 규모면에서 확장 가능하지도 않고 유연하지도 않다. 더 나은 해결책은 레디스와 같은 중앙 집중형 데아터 저장소를 쓰는것이다.


<img src="https://github.com/user-attachments/assets/5f8c2f10-cf79-435e-955d-b1db08d1a55e" width="800">

