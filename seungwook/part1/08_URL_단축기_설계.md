# URL 단축기 설계

긴 원본 URL이 들어왔을때 short URL로 변환해야 하고 해당 URL로 접속하면 원래 URL로 리디렉션 되어야 한다.

## 1단계 문제 이해 및 설계 범위 확정

### 개략적 추정
- 쓰기연산 : 매일 1억 개의 단축 URL 생성
- 초당 쓰기 연산: 1억(100million) / 24 / 3600 = 1160
- 읽기 연산 : 읽기 연산과 쓰기 연산 비율이 10:1, 연산은 초당 1160×10= 11,600회 발생
- URL 단축 서비스를 10년간 운영한다고 가정하면 1억 × 365 × 10 = 3650억 개의 레코드를 보관 필요
- 축약 전 URL의 평균 길이를 100
- 따라서 10년 동안 필요한 저장 용량은 3650억 × 100바이트 = 36.5TB
  
<br>

## 2단계 개략적 설계안 제시 및 동의 구하기

이번 절에서는 API엔드포인트, URL 리디렉션, URL 단축에 대해서 간략하게 살펴보자.

### API 엔드포인트

엔드포인트로는 URL 단축용 엔드포인트와, URL 리디렉션용 엔드포인트가 필요할 것이다.

#### URL 단축용 엔드포인트

- 원본 URL을 보내면 단축 URL을 반환하는 엔드포인트
- POST /api/v1/data/shorten
- 인자 : {longUrl: longURLstring}
- 반환 : 단축 URL

#### URL 리디렉션용 엔드포인트

- 단축 URL을 보내면 원본 URL로 리디렉션하는 엔드포인트
- GET /api/v1/shortUrl
- 반환 : 원본 URL

### URL 리디렉션

단축 URL을 받은 서버는 그 URL을 원래 URL로 바꾸어서 응답의 Location 헤더에 넣어 반환한다.

아래 그림은 클라이언트와 서버 사이의 통신 절차를 좀 더 자세히 보여준다.

<img src="https://github.com/user-attachments/assets/4d3742ab-12d9-449f-93f4-be54ddf80e43" width="800">

여기서 유의할 것은 301응답과 302 응답의 차이다. 둘다 리디렉션 응답이긴 하지만 차이가 있다.

#### 301 Permanently Moved

- 301 응답은 리소스가 영구적으로 다른 URL로 이동했음을 나타낸다.
- 대부분의 브라우저는 캐시에 영구적으로 저장하고, 이후 동일한 요청이 오면 새로운 URL로 바로 접속한다.
- 서버 부하를 줄이는 것이 중요하다면 301 응답을 사용하는 것이 좋다.

#### 302 Found

- 302 응답은 리소스가 임시로 다른 URL로 이동했음을 나타낸다.
- 브라우저는 캐시에 저장하지 않고, 이후 동일한 요청이 오면 다시 서버에 요청한다.
- 트래픽 분석이 중요할 때는 302 응답을 사용하는 것이 클릭 발생률이나 발생 위치를 추적하는데 유용하다.


### URL 단축

단축 URI이 `www.tinyurl.com/{hashvalue}` 같은 형태라고 해보자. 결국 중요한 것은 긴 URL을 이 해시 값으로 대응시킬 해시 함수 fx를 찾는 일이 될 것이다.

- 입력으로 주어지는 긴 URL이 다른 값이면 해시 값도 달라야한다.
- 계산된 해시 값은 원래 입력으로 주어졌던 긴 URL로 복원될 수 있어야 한다.

이 해시 함수에 대한 상세 설계는 다음절에서 살펴본다.

<br>

## 3단계 상세 설계

### 해시 함수

해시 함수는 원래 URL을 단축 URL로 변환하는데 쓰인다. 함수가 계산하는 단축 URL값을 hashValue라고 하자.

#### 해시 값 길이

- hashValue는 `[0-9a-zA-Z]`의 문자로 구성되어 사용할 수 있는 문자의 개수는 **62개**이다.
- 개략적으로 계산했던 추정치에 따르면 3650억개의 URL을 만들어 낼 수 있어야한다.
- 문자열 길이가 7일때 `62 * 62 * 62 ... * 62 = 62^7 = 3.5억개`의 URL을 만들어 낼 수 있다.
- 따라서 7자리 문자열을 사용하면 충분하다.

해시 함수 구현에 쓰일 기술로는 **해시 후 충돌 해소 방법**과 **base-62** 변환법을 살펴보겠다.

#### **해시 후 충돌 해소**

긴 URL을 줄이려면, 원래 URL을 7글자 문자열로 줄이는 해시 함수가 필요하다. **CRC32**, **MD5**, **SHA-1** 같이 잘 알려진 해시 함수를 사용하면 된다.

하지만 해시 함수를 사용하여 나온 가장 짧은 해시값조차도 7보다는 길다. 

그래서 해결 방법으로는 처음 7개 글자만 이용하고, 충돌이 발생하면 충돌이 해결될때 까지 사전에 정한 문자열을 해시값에 덧붙이는 방법을 사용한다.

<img src="https://github.com/user-attachments/assets/62899cc1-3af3-4ec9-9c13-4b208e618ed9" width="800">

이 방법을 쓰면 충돌은 해소할 수 있지만 단축 URL을 생성할 때 한 번 이상 데이터베이스 질의를 해야하므로 오버헤드가 크다.

데이터베이스 대신 **블룸 필터**를 사용하면 성능을 높일 수 있다.

> 블룸필터란 
> 
> 데이터가 집합에 포함되어 있는지 여부를 효율적으로 확인하기 위한 확률적 자료구조이다.
> 
> 시간복잡도는 O(n)이 아니라 O(k)이다. 블룸필터는 데이터 크기 n에 상관없이 블룸 필터의 작동에 필요한 해시함수 개수 k에 영향을 받아 대규모 필터링에 적합하다.

#### **base-62 변환법**

진법 변환(base conversion)은 URL 단축기를 구현할 때 흔히 사용되는 접근법중 하나다.

62진법을 쓰는 이유는 hashValue에 사용할 수 있는 문자가 62개이기 때문이다.


| ID    | 단축 URL | 원본 URL                      |
|-------|--------|-----------------------------|
| 11157 | 2TX    | http://www.google.com/vsewd |

- 원본 URL이 들어오면 고유한 숫자 ID를 부여한다.
- 이 숫자 ID를 62진법으로 변환한다.
- 11157 -> 2TX 로 변환
- 고유 ID는 데이터베이스에서 보장되므로 충돌 걱정 없음.

그러나 해시 후 충돌 해소 방법과는 다르게 유일성 보장 ID 생성기가 필요하다.

#### 두 접근법 비교

| 해시 후 충돌 해소 | base-62 변환법 |
| --- | --- |
| 단축 URL의 길이가 고정됨 | 단축 URL의 길이가 가변적, ID 값이 커지면 같이 길어짐 | 
| 충돌이 가능해서 해소 전략이 필요 | ID의 유일성이 보장된 후에야 적용 가능한 전략이라 충돌 아예 불가능 |
| ID로부터 단축 URL을 계산하는 방식이 아니라서 다음 URL 유추 불가능 | ID가 1씩 증가하는 값이라면 쉽게 다음 단축 URL을 알아낼 수 있어 보안에 취약 |


  
  
