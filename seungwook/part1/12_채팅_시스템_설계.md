# 채팅 시스템 설계

## 1단계 문제 이해 및 설계 범위 확정

이번 장에서는 페이스북 메신저와 유사한 채팅 앱을 설계해볼것이다.

- 응답지연이 낮은 일대일 채팅 기능
- 최대 100명까지 참여할 수 있는 그룹 채팅 기능
- 사용자의 접속상태 표시 기능
- 다양한 단말 지원. 하나의 계정으로 여러 단말에 동시 접속 지원
- 푸시 알림

## 2단계 개략적 설계안 제시 및 동의 구하기

채팅 시스템의 경우 클라이언트는 모바일 앱이나 웹 앱이다. 클라이언트는 직접 통신하지 않고 서버를 통해 통신한다.

![image](https://github.com/user-attachments/assets/a85a1209-b4bd-4cf8-897f-0993461230e1)

### 통신 프로토콜 선택

웹 환경에서 보통은 http통신을 사용하지만 http 통신은 클라이언트가 연결을 만드는 프로토콜이며, 서버에서 클라이언트로 임의 시점에 메시지를 보내는데는 쉽게 쓰일 수 없다.

서버가 연결을 만드는 것처럼 동작할 수 있도록 하기 위해 폴링, 롱폴링, 웹소켓을 사용한다.

- 폴링 : 클라이언트가 서버에게 주기적으로 요청을 보내는 방식
- 롱폴링 : 클라이언트는 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지하는 방식
- 웹소켓 : 클라이언트와 서버가 양방향 통신을 할 수 있는 프로토콜

채팅에 대해서는 웹소켓 프로토콜을 사용하지만 그 외의 기능(회원가입, 로그인, 사용자 프로파일 등)에는 http 프로토콜을 사용한다.

### 저장소 선택

채팅 시스템이 다루는 데이터는 보통 두 가지다.

**첫 번째는 사용자 프로파일, 설정, 친구 목록처럼 일반적인 데이터다.** 이런 데이터는 안정성을 보장하는 관계형 데이터 베이스에 보관한다.

**두 번째는 채팅 이력이다.** 이 데이터를 어떻게 보관할지 결정하려면 읽기/쓰기 연산 패턴을 이해해야 한다.

- 채팅 이력 데이터의 양은 엄청나게 많다.
- 주로 최근에 주고 받은 메시지만 확인하고 사용자는 오래된 메시지는 들여다보지 않는다.
- 검색을 이용하거나 특정 메시지로 점프하여 확인하는 경우도 지원해야한다.
- 1:1 채팅 앱의 경우 읽기:쓰기 비율이 1:1에 가깝다.

이런 특성을 고려하여 채팅 이력 데이터는 키-값 저장소에 저장하는 것이 좋다.

- 키-값 저장소는 수평적 규모확장이 쉽다.
- 관계형 데이터는 보통 long tail (드문 데이터)에 대한 검색이 느리다.
  - 관계형 데이터베이스가 고정된 스키마와 복잡한 조인 연산으로 인해 데이터 다양성과 비정형성에 비효율적이기 때문

## 3단계 상세 설계

상세 설계는 채팅 시스템에서 중요한 부분중 서비스 탐색(service discovery), 메시지 전달 흐름에 대해서 자세히 살펴본다.

### 1. 서비스 탐색(service discovery)

서비스 탐색 기능의 주된 역할은 클라이언트에게 가장 적합한 채팅 서버를 추천하는 것이다.

해당 기능을 구현하는데 널리 쓰이는 아파치 주키퍼가 있다.

사용 가능한 모든 채팅 서버를 등록시켜 두고, 클라이언트가 접속을 시도하면 사전에 정한 기준에 따라 최적의 채팅 서버를 골라주면 된다.

![image](https://github.com/user-attachments/assets/eb891f62-0665-4993-9249-afb47baaf54b)

### 2. 메시지 흐름

- 1:1 채팅 메시지 처리 흐름
- 여러 단말 사이의 메시지 동기화
- 소규모 그룹 채팅 메시지 처리 흐름

#### 1:1 채팅 메시지 처리 흐름

<img src="https://github.com/user-attachments/assets/bad4f131-41f0-4aa1-bab2-c064c40b8147" width="600">

- 사용자 A가 채팅 서버 1로 메시지를 보내면, 메시지가 동기화 큐를 이용해 사용자 B에게 전달되는 구조를 사용한다.

#### 여러 단말 사이의 메시지 동기화

<img src="https://github.com/user-attachments/assets/34774db7-4867-4259-9de1-76bc700080dc" width="600">

각 단말은 `cur_max_message_id`라는 변수를 유지하는데, 이 변수는 해당 단말에서 가장 최근에 읽은 메시지의 ID를 가리킨다.

키값 저장소에서 가져온 메시지 중 `cur_max_message_id`보다 큰 메시지만 가져와서 동기화한다.

#### 소규모 그룹 채팅 메시지 처리 흐름

<img src="https://github.com/user-attachments/assets/7cd31898-abae-4d59-8dc7-12e6840f7594" width="600">

그룹이 크지 않으면 메시지를 수신자별로 복사해서 큐에 넣는 위의 방식이 문제가 되지 않는다.

위챗(WeChat) 이란 서비스가 이런 접근법을 쓰고 있으며, 그룹의 크기는 500명으로 제한하고 있다.

하지만 많은 사용자를 지원해야 하는 경우라면 똑같은 메시지를 모든 사용자의 큐에 복사하는 것 보다는 메시지를 한 번만 저장하고, 그룹의 사용자들에게 메시지를 전달하는 방법을 사용해야 한다.





