## 1장 사용자 수에 따른 규모 확장성

한 명의 사용자를 지원하는 시스템에서 시작하여, 최종적으로는 몇백만 사용자를 지원하는 시스템을 설계해보자.

### 초기구성

모든 컴포넌트가 단 한대의 서버에서 실행되는 간단한 시스템부터 설계해보자.

웹, 앱, 데이터베이스 등이 전부 서버 한 대에서 실행된다.

![image](https://github.com/user-attachments/assets/a2c09b66-eb64-4664-96a2-f0d9dc89f88c)

그러나 위 설계에서 사용자는 웹 서버에 바로 연결되는데 이러면 웹 서버가 다운되면 사용자는 웹 사이트에 접속할 수 없게된다.

또한, 너무 많은 사용자가 접속하여 웹 서버가 한계 상황에 도달하게 되면 응답 속도가 느려지거나 서버 접속이 불가능해질 수 있다.

이런 문제를 해결하기 위해서 로드밸런서와 데이터베이스 다중화를 도입해보자.

### 로드밸런서

로드밸런서는 여러 서버에 대한 트래픽을 고르게 분산하여 서버의 부하를 줄여주는 장치이다.


### 데이터베이스 다중화

서버 사이에 master-slave 관계를 설정하고 데이터 원본은 master서버에, 사본은 slave서버에 저장하는 방식이다.

쓰기 연산은 master에서만 지원한다. 대부분의 애플리케이션은 읽기 연산의 비중이 쓰기 연산보다 훨씬 높으므로 slave 서버에 개수가 많을 수 있다.

![image](https://github.com/user-attachments/assets/7d488df2-40c0-4f00-a9ce-aa75d9aca328)



### 응답시간 개선

이제 웹 계층과 데이터 계층에 대해 충분히 개선하였으니, 응답시간을 개선해보자.

응답 시간은 캐시를 붙이고 정적 콘텐츠를 CDN(Content Delivery Network)에 저장하여 개선할 수 있다.

#### 1. 캐시

캐시는 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소이다.

#### 2. CDN

CDN은 정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크이다. 이미지, 비디오, CSS, JavaScript 파일 등을 캐시할 수 있다.

![image](https://github.com/user-attachments/assets/ddf48a95-37fc-476e-9e18-fb75e909b651)

이제 더 많은 트래픽을 받기 위해서 서버와 데이터베이스를 수평적으로 확장하는 방법에 대해서 알아보자.

### 무상태 웹 계층

웹 계층을 수평적으로 확장하는 방법은 상태정보를 웹 계층에서 제거해야한다.

상태 정보를 관계형 데이터베이스나 NoSQL 같은 지속성 저장소에 보관하고, 필요할 때 읽어와서 사용한다.

이렇게 구성된 웹 계층을 무상태 웹 계층이라고 부른다.

![image](https://github.com/user-attachments/assets/859bae20-6db5-49e5-a468-a317bc8094a3)

세션 데이터를 웹 계층에서 분리하고 지속성 데이터 보관소에 저장했다.

이 공유 저장소는 관계형 데이터베이스일 수도 있고, Memcached나 Redis 같은 메모리 기반 저장소일 수도 있다.

여기서는 NoSQL을 사용하였는데, 규모 확장이 간편해서다.


### 데이터베이스의 규모확장

저장할 데이터가 많아지면 데이터베이스에 대한 부하도 증가한다.

데이터베이스 서버 하드웨어에는 한계가 있으므로 수직적 확장만으로는 한계에 도달하게 되어 수평적 확장이 필요하다.

데이터베이스의 수평적 확장은 샤딩이라고도 부르는데, 더 많은 서버를 추가함으로써 성능을 향상시킬 수 있도록 한다.

### 샤딩

샤딩은 대규모 데이터베이스를 샤드라고 부르는 작은 단위로 분할하는 기술을 일컫는다.

모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복이 없다.

![image](https://github.com/user-attachments/assets/1ba292a9-a354-42be-bb92-7af067fb06fa)

예를들어, 사용자 데이터를 어느 샤드에 넣을지는 사용자 ID에 따라 정한다. `user_id % 4`를 해시함수로 사용하여 데이터가 보관되는 샤드를 정한다.

### 백만 사용자, 그리고 그 이상

해당 책에서 나온 백만 사용자를 지원하는 시스템을 설계하기 위한 내용을 정리해보면

- 웹 계층은 무상태 계층으로
- 모든 계층에 다중화 도입
- 가능한 한 많은 데이터를 캐시할 것
- 여러 데이터 센터를 지원할 것
- 정적 콘텐츠는 CDN을 통해 서비스할 것
- 각 계층은 독립적 서비스로 분할할 것
- 시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것

## Q & A

### 1. 샤딩과 레플리케이션의 차이

샤딩과 레플리케이션 모두 데이터베이스의 수평 확장을 위한 방법이지만, 두 방식의 목적과 구현 방식이 다르기 때문에 서로 보완적인 역할을 하기도 한다.

둘다 데이터베이스를 추가하는 방식이지만 레플리케이션은 전체 데이터를 복제하고, 샤딩은 데이터를 분할하여 저장한다.

#### 개념적 차이

- 샤딩은 데이터를 특정 기준(샤드 키)에 따라 분할하여 각기 다른 서버에 나누어 저장하는 방식, 각 샤드는 데이터의 일부만을 포함하며, 전체 데이터베이스는 여러 샤드에 걸쳐 분산된다.
- 레플리케이션은 데이터를 여러 서버에 복제하여 동일한 데이터 사본을 여러 개 유지하는 방식, 이를 통해 한 서버가 다운되더라도 다른 복제본 서버에서 데이터에 접근할 수 있다.

#### 목적적 차이

- 샤딩은 대량의 데이터를 저장하고 관리할 수 있도록 저장 공간과 읽기/쓰기 성능을 확장하는 것이 목적, 데이터가 각 샤드에 분산되기 때문에, 각 샤드는 자체적으로 데이터를 처리하며 전체 시스템의 부하를 줄일 수 있다.
- 레플리케이션은 주로 데이터의 가용성과 읽기 성능을 향상시키기 위해 사용, 데이터의 복제본을 여러 서버에 유지함으로써, 데이터에 대한 읽기 요청을 분산하고, 데이터베이스 서버의 장애에 대비할 수 있다.


<br>

### 2. 레플리케이션 데이터 동기화는 어떻게 이루어지는가

#### MySQL의 레플리케이션 동작 방식 예시

- 주 서버에서 데이터가 변경되면, 변경 사항이 바이너리 로그(binary log) 파일에 기록
- 복제본 서버는 주 서버의 바이너리 로그 파일을 읽어와 중계 로그(relay log)에 저장
- 중계 로그에 기록된 변경 사항을 복제본 서버에서 실행하여 데이터베이스에 반영


<br>

### 3. RDBMS 샤딩할때 직접구현?

RDBMS 샤딩을 할 때, 대부분의 경우 직접 구현이 필요하다. 이는 RDBMS가 기본적으로 샤딩을 지원하지 않는 경우가 많기 때문

#### 애플리케이션 레벨 샤딩

- 애플리케이션 레벨에서 `user_id`, `order_id` 등 특정 키를 기준으로 데이터를 분배할 샤드를 결정하는 로직을 구현하여 데이터를 샤딩
- 데이터베이스 쿼리를 실행하기전에 샤드 키를 기반으로 어떤 샤드에 접근할지 결정하는 로직을 추가하여, 샤딩된 데이터에 접근

#### 데이터베이스 미들웨어 사용

- 애플리케이션에서 직접 샤딩을 구현하지 않고, 데이터베이스 미들웨어를 통해 샤딩 로직을 관리할 수 있다.
- 대표적으로 Apache ShardingSphere, MySQL Proxy, Vitess 등의 데이터베이스 미들웨어를 사용하여 샤딩된 데이터에 접근할 수 있다.
