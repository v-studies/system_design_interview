# 10장 실시간 게임 순위표

이번장에서는 온라인 모바일 게임의 리더보드, 즉 순위표를 설계해본다.

## 개략적 설계안

![Image](https://github.com/user-attachments/assets/2c5275d2-bb01-4775-9c7b-3e8161dba5a8)

해당 순위표를 설계하기 위해 어떤 DB를 써야하는지 알아보자.


## 1. 관계형 데이터베이스

- 사용자가 경연에서 승리하면 신규 사용자에게 1점을 주고, 기존 사용자에게는 원래 점수에 1을 더한다.
- 점수에 따라 테이블을 내림차순으로 정렬하여 순위 결정

| rank | user_id      | score |
|------|--------------|-------|
| 1    | happy_tomato | 987   |
| 2    | mallow       | 902   |
| 3    | smith        | 870   |
| 4    | mary1934     | 850   |

이 방안은 데이터가 많지 않을 때는 효과적이지만, 레코드가 수백만 개 정도로 많아지면 성능이 나빠지는 문제가 있다.

사용자의 순위를 파악하려면 모든 플레이어를 정렬해야하므로 수백만 개 레코드에 순위를 실시간으로 매기기에는 적합하지 않다.

<br>

## 2. 레디스

레디스는 순위표 시스템 설계 문제를 해결하는 데 이상적인 정렬 집합(sorted set)이라는 자료형을 제공한다.

정렬 집합은 내부적으로 해시 테이블과 스킵 리스트 라는 두 가지 자료 구조를 사용한다.

스킵리스트는 빠른 검색을 가능하게 하는 자료 구조로 정렬된 연결 리스트에 다단계 색인을 두는 구조다.

![Image](https://github.com/user-attachments/assets/8f47f3cc-95b9-45bd-93a9-7558f12fd614)

- 중간 노드를 하나씩 건너뛰는 1차 색인 추가
- 1차 색인 노드를 하나씩 건너뛰는 2차 색인 추가

이런식으로 다단계 색인을 사용하면 45가 있는지 훨씬 빠르게 검색할 수 있다.

그리고 레디스 연산(ZADD, ZRANK ...)을 사용하면 순위표 요구사항을 구현할 수 있다.

### 레디스 규모 확장

더 많은 데이터(약 5억 DAU)를 처리하기 위해서는 샤딩이 필요하다.

데이터 샤딩에는 고정 파티션과 해시 파티션이 있다.

#### 고정 파티션

고정 파티션은 순위표에 등장하는 점수의 범위에 따라 파티션을 나누는 방안이다.

![Image](https://github.com/user-attachments/assets/1f41a6d4-b412-4b40-9fcd-0c03fbf9591b)

이 기능이 제대로 작동하려면 순위표 전반에 점수가 고르게 분표되어야 한다.

#### 해시 파티션

해시 파티션은 레디스 클러스터를 사용하는 것으로, 사용자들의 점수가 특정 대역에 과도하게 모여있는 경우에 효과적이다.

레디스 클러스터는 여러 노드에 데이터를 자동으로 샤딩하는 방법을 제공한다.

![Image](https://github.com/user-attachments/assets/44dc3a7b-30aa-4400-9b14-1af31a4b1888)

그러나 데이터가 각 레디스로 분산 저장되므로 상위 10명의 플레이어를 검색하는 것은 까다롭다.

모든 샤드에서 상위 10명을 받아 애플리케이션 내에서 다시 정렬하는 분산-수집 접근법을 사용해야 한다.

<br>

## 3. NoSQL

대안이 될 만한 다른 한가지 솔루션은 NoSQL이다.

- 쓰기 연산에 최적화 되어있다.
- 같은 파티션 내의 항목을 점수에 따라 효율적으로 정렬 가능하다.

레디스와 MySQL을 DynamoDB로 대체할 수 있다.

### 한달 데이터를 같은 파티션에 보관

![Image](https://github.com/user-attachments/assets/c27d031c-aaab-415e-9672-1203b978b365)

위 방법으로 진행하면 가장 최근 한 달치 데이터가 동일한 파티션에 저장될 뿐 아니라

이번달 부하가 많이 몰리면 핫 파티션이 되고 만다.

이 문제를 해결하기 위해서는 n개 파티션으로 분할하고 파티션 번호를 파티션 키에 추가하는 것이다. (쓰기 샤딩 패턴)

### 한달 데이터를 다른 파티션에 보관

![Image](https://github.com/user-attachments/assets/bb213aa2-ab5e-49e4-b32a-a07b6f4e5816)

같은 달 데이터를 여러 파티션에 고르게 분산시키면 한 파티션이 받는 부하는 낮아진다. 

하지만 특정한 달의 데이터를 읽으려고 하면 모든 파티션을 질의한 결과를 합쳐야 하므로 구현은 복잡하다.



