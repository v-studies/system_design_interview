# 4장 분산 메시지 큐

현대적 소프트웨어 아키텍처를 따르는 시스템은 잘 정의된 인터페이스를 경계로 나뉜 작고 독립적인 블록들로 구성된다.

메시지큐는 이 블록 사이의 통신과 조율을 담당한다.

메시지 큐를 사용하면 아래와 같은 이득을 얻을 수 있다.

- 결합도 완화
- 규모 확장성 개선
- 가용성 개선
- 성능 개선

<br>

## 메시지 큐 vs 이벤트 스트리밍 플랫폼

카프카는 메시지 큐가 아니라 이벤트 스트리밍 플랫폼이다.

하지만 메시지큐와 이벤트 스트리밍 플랫폼 사이의 차이는 지원하는 기능이 서로 수렴하면서 점차 희미해지고 있다.

<br>

## 메시지 모델

### 일대일방식 (RabbitMQ)

RabbitMQ는 기본적으로 큐(Queue) 기반의 메시징 시스템으로, 일대일 방식으로 메시지를 처리한다.

큐에 있는 메시지는 한 소비자에게만 전달된다. 즉, 한 번 소비자가 메시지를 가져가면, 다른 소비자에게는 그 메시지가 전달되지 않으며, 메시지는 큐에서 사라진다.

### 발행-구독 방식 (Kafka)

Kafka는 토픽(Topic) 기반의 메시징 시스템으로, 발행-구독(Pub/Sub) 모델을 따른다.

Kafka에서는 메시지가 여러 소비자에게 동시에 전달될 수 있다. 또한, 메시지가 토픽에 보존되므로, 여러 소비자가 동시에 또는 나중에 메시지를 읽을 수 있다.

하지만 RabbitMQ에서도 Exchange를 사용하면, 기본적인 큐(Queue) 기반의 일대일 방식 외에도 더 복잡한 메시지 라우팅 패턴을 만들 수 있다.

## RabbitMQ Exchange 종류

Exchange는 메시지를 특정 큐로 라우팅하는 역할을 하며, 다양한 라우팅 전략을 지원한다. 따라서 Exchange를 사용하면 발행-구독(Pub/Sub) 모델을 구현할 수 있다.

### 1. Direct Exchange

일대일 라우팅 방식으로, 메시지를 특정 라우팅 키에 기반해 정확한 큐로 라우팅한다.

예를들어 프로듀서가 routingKey = "error"로 메시지를 보내면, 해당 routingKey와 바인딩된 큐로만 메시지가 전달된다.

### 2. Fanout Exchange

발행-구독(Pub/Sub) 방식으로, 메시지가 모든 바인딩된 큐로 전달된다. 라우팅 키는 사용되지 않으며, Exchange에 바인딩된 모든 큐에 메시지가 전달된다.

### 3. Topic Exchange:

패턴 기반 라우팅 방식으로, 라우팅 키에 *(와일드카드) 또는 #를 사용하여 여러 큐로 메시지를 보낼 수 있다.


<br>

## kafka 파헤치기

### 토픽, 파티션, 브로커

앞서 언급했듯이 메시지는 **토픽**에 보관된다.

토픽에 보관되는 데이터의 양이 커져서 서버 한 대로 감당하기 힘들면 **파티션** 즉 샤딩 기법을 사용한다.

![Image](https://github.com/user-attachments/assets/4332dbf8-b882-4f2d-9765-0be2d4654d23)

토픽을 여러 파티션으로 분할한 다음에 메시지를 모든 파티션에 균등하게 나눠보낸다.

파티션을 유지하는 서버를 **브로커**라 부른다.

![Image](https://github.com/user-attachments/assets/89173d01-6812-479c-b487-9268f0adf582)

요약하면 Kafka에서 토픽은 여러 파티션으로 나눠지고, 각 파티션은 여러 브로커에 분산되어 저장된다. 

이 방식은 Kafka의 확장성, 고가용성, 그리고 높은 처리량을 가능하게 한다.

### 소비자 그룹과 오프셋

하나의 소비자 그룹은 여러 토픽을 구독할 수 있고 오프셋을 별도로 관리한다.

같은 그룹내의 소비자는 메시지를 병렬로 소비할 수 있다.

![Image](https://github.com/user-attachments/assets/7206b2c3-83b1-4a88-8459-aafd1c488681)

- 소비자 그룹 1은 토픽 A를 구독한다
- 소비자 그룹 2는 토픽 A와 토픽 B를 구독한다.

데이터를 병렬로 읽으면 대역폭 측면에서는 좋지만 같은 파티션 안에 있는 메시지를 순서대로 소비할 수는 없다.

예를들어 소비자-1과 소비자-2가 같은 파티션-1의 메시지를 읽어야한다고 할 때, 파티션-1 내의 메시지 소비 순서를 보장할 수 없게 된다.

### kafka 파티션이 순서를 보장하는 방법

kafka는 파티션 내 메시지의 순서를 보장하기 위해서 아래 제약사항을 사용하고 있다.

**파티션의 메시지는 한 그룹 안에서는 오직 한 소비자만 읽을 수 있도록 하는 것이다**.

> 소비자 그룹이 다르면, 각 소비자 그룹은 독립적으로 메시지를 소비하고, 각 그룹은 자기만의 오프셋을 관리하기 때문에 상관없다.

그리고 또 하나의 소비자가 여러 파티션을 구독하는건 상관없다.

- 각 파티션은 독립적인 메시지 순서를 가지므로 순서 보장됨 
- 해당 파티션들은 당연히 하나의 소비자만 가져야함



### 위 제약사항에 단점

위 제약사항을 도입한 후에 모든 소비자를 같은 소비자 그룹에 두면 같은 파티션의 메시지는 오직 한 소비자만 가져갈 수 있으므로 결국 일대일 모델에 수렴하게 된다.

파티션은 가장 작은 저장 단위이므로 미리 충분한 파티션을 할당 해두면 파티션의 수를 동적으로 늘리는 일은 피할 수 있다.

처리 용량을 늘리려면 소비자를 더 추가하면 된다.

> 다만 파티션 수는 한번 늘어나면 줄일 수 없기에 신중해야 한다.


<br>


## 개략적 설계안

![Image](https://github.com/user-attachments/assets/a4d3853a-499e-4069-9ef5-b1ec13e2a335)

- 조정 서비스
  - 서비스 탐색 : 어떤 브로커가 살아있는지 알려준다.
  - 리더 선출 : 브로커 가운데 하나는 컨트롤러 역할을 담당해야 하며, 한 클러스터에는 반드시 활성 상태 컨트롤러가 하나 있어야 한다. 이 컨트롤러가 파티션 배치를 책임진다.
  - 아파치 주키퍼나 etcd가 보통 컨트롤러 선출을 담당하는 컴포넌트로 널리 이용된다.

### 주키퍼 추가 버전

![Image](https://github.com/user-attachments/assets/969f10a1-1007-4bb0-be5e-5d51c9b71638)
