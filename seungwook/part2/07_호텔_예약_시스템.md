# 7장 호텔 예약 시스템

### 데이터 모델

호텔 웹사이트를 방문하는 사용자의 수는 실제로 객실을 예약하는 사용자에 비해 압도적으로 많다.

nosql 데이터베이스는 대체로 쓰기 연산에 최적화되어 있어서 읽기 빈도가 높은 서비스인 호텔 예약시스템은 관계형 데이터베이스를 사용하는게 좋다.

### 개략적 설계안

![Image](https://github.com/user-attachments/assets/6b22abaa-8426-456f-a8fb-25fc6b78e343)

- 마이크로서비스 아키텍처를 사용한다.

<br>

## 개선된 데이터 모델

호텔 객실을 예약할 때는 특정 **객실(roomId)** 이 아니라 특정한 **객실 유형(roomTypeId)** 을 사용해야 한다.

![Image](https://github.com/user-attachments/assets/6e483a10-fd81-46f1-88f4-6206df7644bd)


- 예약서비스에서 reservation 테이블만 사용하는게 아니라 room_type_inventory 테이블도 사용해줘야 한다.

![Image](https://github.com/user-attachments/assets/f3f0c5a6-3f41-4d0a-bc40-b2648d9cc905)

- 해당 유형의 객실에 여유가 있고 사용자가 예약 가능한 상태인지 질의 후 예약할 수 있도록 함

<br>

## 동시성 문제

이중 예약을 방지하기 위해서 아래 두 가지 문제를 해결해야 한다.

### 1. 같은 사용자가 여러번 요청

#### 클라이언트측 구현

예약 후 예약 버튼 숨기기 등으로 해결할 수 있지만 자바스크립트 비활성화 등 우회할 방법이 있으므로 안정적인 방법이 아니다.

#### 멱등 API

![Image](https://github.com/user-attachments/assets/41fb74c3-d310-483f-ab41-5439278720dd)

- 예약 API 요청에 멱등 키를 추가하는 방법이다.
- 몇번을 호출해도 같은 결과를 내는 API를 멱등 API라고 부른다.

![Image](https://github.com/user-attachments/assets/99656a8e-04e2-44f7-9325-8354fb856a8e)

- reservation_id가 예약 테이블의 기본 키이므로 기본 키의 유일성 조건이 위반되어 새로운 레코드는 생성되지 않는다.

### 2. 여러 사용자가 동시에 예약 요청

![Image](https://github.com/user-attachments/assets/d1b0a91b-9bd4-4f5f-9822-ba5535922224)

이 문제를 해결하려면 어떤 형태로든 락을 활용해야 한다.

#### 비관적락

MySQL의 경우 `SELECT ... FOR UPDATE` 문을 실행하면 SELECT가 반환한 레코드에 락이 걸린다.

![Image](https://github.com/user-attachments/assets/b85e65af-a536-4319-9302-e0a5bfdf0f8c)

- 장점 : 구현이 쉽고 모든 갱신 연산을 직렬화하여 충돌을 막는다. 비관적 락은 데이터에 대한 경합이 심할 때 유용하다.
- 단점 : 트랜잭션이 너무 오랫동안 락을 해제하지 않고 있으면 다른 트랜잭션은 락이 걸린 자원에 접근할 수 없어 성능에 영향이 있을 수 있다.

호텔 예약 시스템에 비관적 락 메커니즘을 사용하는 것은 권장하지 않는다.

#### 낙관적락

낙관적락은 일반적으로 버전 번호를 통해 관리한다.

![Image](https://github.com/user-attachments/assets/5c30deff-3233-4e38-94eb-c88034db82bc)

- 장점 : 데이터베이스 자원에 락을 걸 필요가 없다. 데이터에 경쟁이 치열하지 않은 상황에 적합하다.
- 단점 : 데이터에 대한 경쟁이 치열하면 재시도로 인해 성능이 좋지 않다.

호텔 예약 QPS가 일반적으로 높지 않기 때문에 낙관적락은 적합한 선택지이다.

#### 데이터베이스 제약조건

이 접근법은 낙관적 락과 아주 유사하다.

```sql
CONSTRAINT check_room_count CHECK((total_inventory - total_reserved >= 0))
```

![Image](https://github.com/user-attachments/assets/effcf69d-26b7-442f-a1c4-3516b36b14ba)

사용자가 객실을 동시에 예약하려 할때 두번째 요청은 (100 - 101 < 0) 이 되므로 실패하게 되어 롤백된다.

- 장점 : 구현이 쉽다.
- 단점 : 데이터베이스 제약조건은 애플리케이션 코드와 달라서 통제하기 어렵다.

<br>

## 서비스 간 데이터 일관성

![Image](https://github.com/user-attachments/assets/1aebea35-862d-45e3-aff2-90bebaba258f)

모노리스 아키텍처의 경우에는 여러 연산을 하나의 트랜잭션으로 묶어 ACID속성이 만족되도록 보장할 수 있다.

하지만 각 서비스가 독자적인 데이터베이스를 갖도록 하면, 논리적으로는 하나의 원자적 연산이 여러 데이터베이스에 걸쳐 실행되는 일을 피할 수 없다.

하나의 트랜잭션으로 데이터 일관성을 보증하는 기법을 사용할 수 없다는 뜻이다.

![Image](https://github.com/user-attachments/assets/43e7545f-1001-4e7a-a618-443444e29ed6)

이런 데이터 일관성 문제를 해결하기 위해 업계에서 널리 사용되는 방법이 있다.

### 2단계 커밋

2PC는 여러 노드에 걸친 원자적 트랜잭션 실행을 보증하는 데이터베이스 프로토콜이다.

즉, 모든 노드가 성공하든 아니면 실패하든 둘 중 하나로 트랜잭션이 마무리되도록 보증한다는 것이다.

하지만 MSA에서는 각 서비스가 독립적인 DB를 사용하기 때문에, 하나의 서비스가 여러 DB를 직접 다루는 2PC 방식은 MSA의 독립성 원칙에 어긋난다.

따라서 MSA에서는 2PC 대신 Saga 같은 결과적 일관성 패턴을 주로 사용한다.

### 사가(Saga)

각각의 트랜잭션은 완료되면 다음 트랜잭션을 시작하는 트리거로 쓰일 메시지를 만들어 보낸다.

어느 한 트랜잭션이라도 실패하면 사가는 그 이전 트랜잭션의 결과를 전부 되돌리는 트랜잭션들을 순차적으로 실행한다.

사가는 각 단계가 하나의 트랜잭션이라서 **결과적 일관성(eventual consistency)** 에 의존하는 것으로 보아야 한다.


