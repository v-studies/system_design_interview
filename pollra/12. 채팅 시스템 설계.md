# 1단계: 문제 이해 및 설계 범위 확정
## 채팅 앱에도 여러 종류가 있다
- 이 책에서 계속해서 말 하고 있는 것.
- 단순히 예측해서 쉽게 단언하지 말고 질문을 통해 요구사항을 확실하게 하자
## 질문 키워드
- 어떤 앱인가?
- 어떤 클라이언트를 지원해야 하는가? 웹? 앱?
- 트래픽 규모는?
- 비즈니스적 핵심 로직의 제한 사항?
- 중요 기능은 어떤 것? 예를 들어 첨부파일 지원해야 함?
- 한 번에 보낼 수 있는 문자열 제한?
- 암호화 기능 지원?
- 영속화 지원 여부?
# 2단계: 개략적 설계안 제시 및 동의 구하기
## 어떤 프로토콜?
- HTTP 폴링
- HTTP 롱 폴링
- WebSocket
## 상태 유지가 필요한 서비스?
- 본 설계안에서 상태 유지가 필요한 서비스는 채팅 서비스 뿐
## 제3자 서비스 연동?
- 알림 서비스(APNS) 등의 연동이 필요 하다면 해당 부분까지 고려
## 개략적 설계안
![[스크린샷 2024-12-10 오후 3.36.42.png]]
## 저장소
### 키-값 저장소
- 스케일 아웃이 비교적 쉽다
- 데이터 접근 지연시간이 낮다
- 관계형 데이터베이스는 롱테일에 해당하는 부분을 잘 처리하지 못하는 경향 있음
- 많은 안정적인 채팅 시스템이 키-값 저장소를 채택하고 있다
	- Facebook: HBase
	- Discord: Cassandra
### message_id
아래의 속성을 만족하는 id 이어야 한다
- message_id 는 고유해야 한다
- 정렬 가능해야 하며 시간 순서와 일치해야 한다
NoSQL 에서는 해당되는 기능을 제공하지 않으므로 아래의 대안이 있다
- 스노플레이크
- 시퀀스 번호 생성기
이 예제 에서는 시퀀스 번호 생성기를 채택 하였는데, 스노플레이크 같은 전역적 ID 생성기에 비해 구현하기 쉽기 때문이다
# 3단계: 상세 설계
## 서비스 탐색
주된 역할은 클라이언트에게 가장 적합한 채팅 서버를 추천하는 것
이 때 사용되는 기준은 아래와 같음. (아래의 예시보다는 많지만 책에서 제공하는 것은 이것 뿐)
- 클라이언트의 위치 (geographical location)
- 서버의 용량 (capacity)
서비스 탐색 기능을 구현 하는 데에 주로 사용되는 오픈소스는 ?
- 아파치 주키퍼 
### 주키퍼 흐름
![[스크린샷 2024-12-10 오후 4.42.36.png]]
- 사용자에게 가장 적합한 채팅 서버를 찾아 사용자에게 반환, 웹소켓 서버와 연결을 수행 한다
## 메시지 흐름
![[스크린샷 2024-12-10 오후 4.59.39.png]]
1. 사용자 A 가 채팅 서버 1로 메시지 전송
2. ID 생성기에 의해 메시지의 ID 결정
3. 해당 메시지를 메시지 동기화 큐로 전송
4. 키-값 저장소에 채팅 데이터 보관
	1. 사용자B 가 접속 중인 경우
	   접속중인 채팅 서버로 전송
    2. 사용자B가 접속 중이 아니라면
       푸시 알림 메시지를 푸시 알림 서버로 보냄
5. 채팅서버 2 는 메시지를 사용자 B 에게 전송. 사용자 B 와 채팅서버 2 사이에는 웹소켓 연결이 있는 상태 이므로 그것을 이용
### 여러 단말 사이의 동기화
![[스크린샷 2024-12-10 오후 5.13.36.png]]
- 사용자는 두 개의 단말이 모두 켜져 있으며 '채팅서버 1' 과 연결 되어 있다
- 두 단말 모두 웹소켓에 연결 되어 있다
- cur_max_message_id : 해당 단말에서 관측된 가장 최신 메시지의 ID 를 추적하는 용도로, 아래의 두 조건을 만족하는 메시지는 새 메시지로 간주한다
	- 수신자 ID 가 현재 로그인한 사용자 ID 와 같다
	- 키-값 저장소에 보관된 메시지로서, 그 ID 가 cur_max_message_id 보다 크다
위 예시는 랩톱이 최신 메시지로 취급 되며 모바일 단말은 최신 메시지가 아니게 된다
### 소규모 그룹 채팅에서의 메시지 흐름
- 그룹에 3명이 있다고 가정
- 아래의 설계는 소규모 채팅에서만 적합
	- 새로운 메시지가 왔는지 확인 하려면 자기 큐만 보면 되니까 메시지 동기화 플로우가 단순함
	- 그룹이 크지 않으면 메시지를 수신자 별로 복사해서 큐에 넣는 작업의 비용이 문제가 되지 않는다
![[스크린샷 2024-12-10 오후 5.20.03.png]]
이러한 접근법은 WeChat 에서 사용중인 접근법 이다 (그룹의 크기는 500명으로 제한 [@참고문헌-5])
많은 사용자를 지원해야 하는 경우라면 똑같은 메시지를 모든 사용자의 큐에 복사하는 것은 바람직하지 않다
 아래는 한 수신자 가 받아야 하는 프로세스를 그린 것. 대규모에는 적합하지 않은 모습이다.
 ![[스크린샷 2024-12-10 오후 5.28.45.png]]
## 접속 상태 표시
- 접속 상태 서버는 클라이언트와 웹소켓으로 통신하는 실시간 서비스
- 사용자의 상태가 바뀌는 시나리오 정리
### 시나리오_1: 사용자 로그인
- 로그인 하면 아래의 데이터를 저장
	- 사용자의 상태 -> 온라인
	- 마지막 활성 시간 -> 로그인 한 시간 기록
![[스크린샷 2024-12-10 오후 5.34.41.png]]
### 시나리오_2: 로그아웃
![[스크린샷 2024-12-10 오후 5.35.07.png]]
### 시나리오_3: 접속 장애
- 인터넷 연결은 언제나 안정적이지는 않다
	- 끊어질 때 마다 로그아웃을 표현 하는 것은 사용자 경험상 바람직하지는 않다.
대안으로는, heartbeat 검사를 통해 해결하는 방법이 있다
- 온라인 상태의 클라이언트로 하여금 주기적으로 heartbeat event 를 날려 해결한다
- x 초 이내에 또 다른 박동(heartbeat) 이벤트를 받으면 사용자의 접속 상태를 계속 온라인으로 유지
![[스크린샷 2024-12-10 오후 5.52.54.png]]
#### 상태 정보의 전송
- 사용자들이 친구들의 로그인 상태를 알게 되는 것 역시 비즈니스에 속함
- 상태 정보 서버는 발행-구독 모델(Pub/Sub) 을 사용하는데, 각각의 친구 관계 마다 채널을 하나씩 두는 것이다
![[스크린샷 2024-12-10 오후 6.05.37.png]]
- 친구 관계마다 채널을 하나씩 부여
- 이 방법은 그룹 크기가 작을 때 효과적임
# 4단계: 마무리
시간이 좀 남는다면 면접관과 다음 같은 내용을 논의 해도 좋음
- 채팅 앱을 확장 하여 사진이나 비디오 등의 미디어를 지원하도록 하는 방법 논의
	- 미디어 파일의 압축 방식
	- 클라우드 저장소
	- 썸네일 생성
- 종단 간 암호화. 메시지 발신인과 수신자 이외에는 채팅을 볼 수 없다
- 캐시. 읽은 메시지의 캐싱 방식 논의
- 로딩 속도 개선 방식 논의
	- 슬랙은 사용자의 데이터, 채널 등을 지역적으로 분산하는 네트워크를 구축하여 앱 로딩 속도를 개선하였다
- 오류 처리
	- 채팅 서버 오류 논의
	- 메시지 재전송 기법 논의
---
# 참고 문헌
1. [페이스북 채팅](https://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf)
2. [Messenger and WhatsApp process 60 billion messages a day](https://www.theverge.com/2016/4/12/11415198/facebook-messenger-whatsapp-number-messages-vs-sms-f8-2016
3. [Long tail](https://en.wikipedia.org/wiki/Long_tail)
4. [[12-04. The Underlying Technology of Message]]
5. [How Discord Stores Billions of Messages](https://blog.discordapp.com/how-discord-stores-billions-of-messages-7fa6ec7ee4c7)
6. [Announcing Snowflake](https://blog.twitter.com/engineering/en_us/a/2010/announcing-snowflake.html)
7. [Apache ZooKeeper](https://zookeeper.apache.org/)
8. [From nothing: the evolution of WeChat background system (Article in Chinese)](https://www.infoq.cn/article/the-road-of-the-growth-weixin-background)
9. [End-to-end encryption](https://faq.whatsapp.com/en/android/28030015/)
10. [Flannel: An Application-Level Edge Cache to Make Slack Scale](https://slack.engineering/flannel-an-application-level-edge-cache-to-make-slack-scale-b8a6400e2f6b)
11. 