> [!네트워크 시스템에서 처리율 제한 장치(Rate limiter)]
> - 클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치
> - 특정 기간 내에 전송되는 클라이언트의 요청 횟수를 제한 한다
# 처리율 제한 장치(Rate limiter)
api 요청 횟수가 제한 장치에 정의된 임계치(Threshold)를 넘어서면 추가로 도달한 모든 호출은 처리가 중단(Block) 된다
- 사용자는 초당 1회 이상 새 글을 올릴 수 없다
- 같은 ip 주소로는 하루에 10개 이상의 계정을 생성 할 수 없다
- 같은 디바이스로는 주당 5회 이상의 리워드(reward) 요청을 할 수 없다
## 처리율 제한 장치의 장점
- DoS(Denial of Service) 공격에 의한 자원 고갈(resource starvation)을 방지 할 수 있다.
	- 트위터: 3시간 동안 300개의 트윗만 올릴 수 있도록 제한 하고 있다
	- 구글독스: 사용자당 분당 300회의 read 요청만 허용한다
- 비용을 절감 한다(비정상적인 요청에 의한) 
- 서버 과부하를 막는다(비정상적인 요청에 의한)
> [! 비정상적인 요청?]
> bot, 잘못된 이용 패턴으로 인한 트래픽, 악의적인 목적의 공격 등

# 1. 문제 이해 및 설계 범위 확정
```
지원자: 어떤 종류의 처리율 제한 장치를 설계해야 하나요? 클라이언트 측 제한 장치입니까, 아니면 서버 측 제한 장치입니까?
면접관: 좋은 질문이에요. 서버측 API를 위한 장치를 설계한다고 가정합시다.

지원자: 어떤 기준을 사용해서 API 호출을 제어해야 할까요? IP 주소를 사용해야 하나요? 아니면 사용자 ID? 아니면 생각하는 다른 어떤 기준이 있습니까?
면접관: 다양한 형태의 제어 규칙(throttling rules)을 정의할 수 있도록 하는, 유연한 시스템이어야 합니다.

지원자: 시스템 규모는 어느 정도여야 할까요? 스타트업 정도 회사를 위한 시스템입니까 아니면 사용자가 많은 큰 기업을 위한 제품입니까?
면접관: 설계할 시스템은 대규모 요청을 처리할 수 있어야 합니다.

지원자: 시스템이 분산 환경에서 동작해야 하나요?
면접관: 그렇습니다.

지원자: 이 처리율 제한 장치는 독립된 서비스입니까 아니면 애플리케이션 코드에 포함될 수도 있습니까?
면접관: 그 결정은 본인이 내려주시면 되겠습니다.

지원자: 사용자의 요청이 처리율 제한 장치에 의해 걸러진 경우 사용자에게 그 사실을 알려야 하나요?
면접관: 그렇습니다.
```
## 위 대화에서 나온 요구사항
- 설정 된 처리율을 초과하는 요청은 정확하게 제한한다
- 낮은 응답시간: 이 처리율 제한 장치는 HTTP 응답 시간에 나쁜 영향을 주어서는 곤란하다
- 가능한 한 적은 메모리를 써야 한다
- 분산형 처리율 제한(Distributed rate limiting): 하나의 처리율 제한 장치를 여러 서버나 프로세스에서 공유 할 수 있어야 한다
- 예외 처리: 요청이 제한 되었을 때는 그 사실을 사용자에게 분명하게 보여주어야 한다
- 높은 결함 감내성(Fault tolerance): 제한 장치에 장애가 생기더라도 전체 시스템에 영향을 주어서는 안된다
# 2. 개략적 설계안 제시 및 동의 구하기
## 처리율 제한 장치는 어디에 둘 것인가?
- 클라이언트(Web 또는 모바일과 같이 유저의 접근 엔드포인트)
	- 클라이언트 요청은 쉽게 위변조가 가능함
	- 모든 클라이언트의 구현을 통제하는 것은 어려움
- 서버
	- ![[스크린샷 2024-11-17 오후 3.41.34.png]]
- 미들웨어
	- ![[스크린샷 2024-11-17 오후 3.42.05.png]]
	- ![[스크린샷 2024-11-17 오후 3.43.26.png]]
### 고려해야 할 부분
- 현재 사용하는 언어가 서버측 구현을 지원하기 충분할 정도로 효율이 좋은가?
- 제 3 사업자가 제공하는 게이트웨이를 사용하기로 했다면, 사업 필요에 맞는 처리율 제한 알고리즘을 지원하는지 고려해야 한다
- 설계가 마이크로서비스에 기반하며 API 게이트웨이를 이미 설계에 포함시켰다면, 처리율 제한 기능 또한 게이트웨이에 포함시켜야 할 수도 있다
- 인력은 충분 한가?
  처리율 제한 장치를 구현 하는데에는 시간과 돈이 든다. 구현 하기에 충분한 인력이 없다면 상용 API 게이트웨이를 쓰는 것이 바람직한 방법일 수 있다
## 처리율 제한 알고리즘
- [[04-01. 토큰 버킷(Token bucket)]]
- [[04-02. 누출 버킷(Leaky bucket)]]
- [[04-03. 고정 윈도 카운터(Fixed window counter)]]
- [[04-04. 이동 윈도 로그(Sliding window log)]]
- [[04-05. 이동 윈도 카운터(Sliding window counter)]]
## 개략적인 아키텍처
처리율 제한 장치는 어떠한 엔드 포인트로의 접근을 특정 횟수 이상 넘지 않도록 하는 것이다
따라서 이러한 카운터를 보관 할 장소가 필요한데, RDBMS 는 디스크 접근 때문에 느릴 수 있으므로 메모리상에서 동작하는 캐시가 바람직 하다
일례로 레디스는 처리율 제한 장치를 구현할 때 자주 사용되는 메모리 기반 저장장치로 INCR, EXPIRE 두 명령어를 지원한다
- INCR: 메모리에 저장된 카운터 값을 1 증가 시킨다
- EXPIRE: 카운터에 타임아웃 값을 지정한다. 설정된 시간이 지나면 카운터는 자동으로 삭제됨
아래는 위 내용을 포함하여 제안 할 수 있는 개략적인 아키텍처 이다
![[스크린샷 2024-11-17 오후 7.36.36.png]]
1. 클라이언트가 처리율 제한 미들웨어 에게 요청을 보낸다
2. 처리율 제한 미들웨어는 레디스의 지정 버킷에서 카운터를 가져와서 처리율을 검사한다
3. 검사 결과에 따라 허용/거부 한다
# 3. 상세 설계
## 처리율 제한 장치의 설정
처리율 제한 장치는 목적에 따라 변할 수 있는 제한 설정을 가지고 있다
이러한 설정 관련 값은 아래와 같은 설정 값으로 분리 하는것이 좋을 것이다
```yaml
domain: messaging
descriptors:
	- key: message_type
	- value: marketing
	- rate_limit:
		unit: day
		request_per_unit: 5
```
## 처리율 한도 초과 트래픽의 처리
- 한도 제한이 걸린 유저에게는 429 응답(Too many requests)을 리턴 한다
- 경우에 따라, 한도 제한에 걸린 메시지를 나중에 처리하기 위해 큐에 저장할 수 있다
	- 주문 시스템의 과부하로 한도 제한에 걸렸다. 해당 주문들은 보관 했다가 나중에 처리 할 수도 있을 것이다
### 처리율 제한 장치가 사용하는 HTTP 헤더
클라이언트의 요청이 `처리율 제한에 걸렸는지` 를 알려주기 위해 HTTP 헤더를 사용할 수 있다
 - X-Ratelimit-Remaining: 윈도 내에 남은 처리 가능 요청 수
 - X-Ratelimit-Limit: 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수
 - X-Ratelimit-Retry-After: 한도 제한에 걸리지 않으려면 몇 초 뒤에 요청을 다시 보내야 하는지 알림
## 상세 설계
- 처리율 제한 규칙은 디스크에 보관
- Workers 는 수시로 규칙을 디스크에서 읽어 캐시에 저장한다
- 클라이언트가 요청을 서버에 보내면 요청은 먼저 `처리율 제한 장치` 에 도달한다
- 처리율 제한 장치는 제한 규칙을 캐시에서 가져온다
	- 처리율 제한에 걸리는 경우 429 응답. 
		- 해당 요청은 버릴수도 있고 큐에 보관할 수도 있다
	- 처리율 제한에 걸리지 않는 경우, 요청을 api 서버로 보낸다
![[스크린샷 2024-11-17 오후 7.53.17.png]]
위 설계는 분산 환경에서 문제가 있음
- 경쟁 조건 (Race condition)
- 동기화 (Synchronization)
### 경쟁 조건 해결
- 경쟁 조건은?
	- 레디스에서 카운터의 값을 읽는다(Counter)
	- counter + 1 의 값이 임계치를 넘는지 본다
	- 넘지 않는다면 카운터 1 증가
- 해결 방법?
	- 가장 간단한 방법은 락(Lock)
	- [루아 스크립트(Lua script)](https://stripe.com/blog/rate-limiters)
	- [정렬 집합(Sorted set)](https://engineering.classdojo.com/blog/2015/02/06/rolling-rate-limiter/)
- 성능 최적화
	- 물리적 접근 서버의 거리때문에 발생하는 네트워크 레이턴시
- 모니터링
	- 채택된 처리율 제한 알고리즘이 효과적인지?
	- 정의한 처리율 제한 규칙이 효과적인지?
# 4. 마무리 추가 지식
- 경성(Hard) 또는 연성(Soft) 처리율 제한
	- 경성 처리율 제한: 요청의 개수는 임계치를 절대 넘을 수 없다
	- 연성 처리율 제한: 요청 개수는 잠시 동안은 임계치를 넘을 수 있다
- 다양한 계층에서의 처리율 제한
	- iptable 을 이용해 OSI 3 계층에서도 처리 가능
- 처리율 제한을 회피하는 방법? (다른방법도 있을텐데 굳이? 라는 뉘앙스)
	- 클라이언트 캐시를 사용하여 api 호출 횟수 줄이기
	- 처리율 제한의 임계치를 이해하고, 짧은 시간동안 너무 많은 메시지를 보내지 않도록 설정
	- 예외나 에러 처리를 통해 클라이언트가 예외적 상황에서 우아하게(Gracefully) 복구되도록 설정
	- 충분한 Back-off 시간을 둔 Retry
