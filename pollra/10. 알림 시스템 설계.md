![[스크린샷 2024-12-03 오후 7.26.53.png]]
# 1단계: 문제 이해 및 설계 범위
- 어떤 종류 알림 지원?
	- 푸시 알림, SMS 메시지, 이메일
- 실시간 - 가능한 빨리 전달 되어야 하나 약간의 지연은 무방함
- 지원 단말: IOS, 안드로이드, 랩톱/데스크톱
- 사용자가 보내는 알림은 누가 생성?
	- 클라이언트
	- 서버측 스케줄링
- 알림 거부 기능 존재
- 하루에 몇 개의 알람을 보낼 수 있어야 함?
	- 천만건의 푸시 알림
	- 백만건의 SMS
	- 오백만건의 이메일
# 2단계: 개략적인 설계안 제시 및 동의 구하기
## 알림 유형별 정리
### IOS
![[스크린샷 2024-12-03 오후 7.31.56.png]]
- 알림 제공자: 알림을 만들어 APNS 로 보내는 주체
	- 필요 데이터
		- 단말 토큰: 알림 전송 시 필요한 고유 식별자
		- 페이로드
- APNS(Apple Push Notification Service) : 애플이 제공하는 원격 서비스. 알림을 IOS 장치로 보내는 역할
- IOS 단말: 푸시 알림 수신하는 사용자
### 안드로이드
![[스크린샷 2024-12-03 오후 7.34.33.png]]
- APNS 대신 FCM(Firebase Cloud Messaging) 사용
- 나머진 같음
### SMS 메시지
![[스크린샷 2024-12-03 오후 7.35.19.png]]
- SMS 서비스는 보통 트윌리오, 넥스모 같은 제 3 사업자 서비스를 많이 사용
- 나머진 같음
### 이메일
- 많은 회사들이 구현하는 것 보다는 상용 서비스 구매를 선택함
	- 센드그리드
	- 메일침프
- 전송 성공률 높고 데이터 분석 서비스 제공
![[스크린샷 2024-12-03 오후 7.37.36.png]]
## 연락처 정보 수집 절차
![[스크린샷 2024-12-03 오후 7.38.20.png]]
## 개략적인 설계안
![[스크린샷 2024-12-03 오후 7.39.23.png]]
- 서비스 1~N
	- 사용자에게 알림을 보내려는 주체
- 알림 시스템
	- 여기선 서버 1개만 사용한다고 가정
	- 위의 서비스에게 알림 전송을 위한 api 엔드포인트 제공
	- 제 3자 제공 서비스에 페이로드를 만들어낼 수 있어야 함
- 제 3자 서비스
	- 사용자에게 알림을 실제로 전달하는 역할
	- 확장성 고려 잘 해야함
		- 어떤 서비스는 시장에서 사용하지 못함
		- 중국에서는 Jpush, PushY 등을 사용해야함
- 단말
	- 알림을 수신하는 사용자
### 문제점
- SPOF(Single-Point-Of-Failure) : 단일 실패 지점
	- 서비스가 한대밖에 없기 때문에 장애 발생 할 경우 전체 서비스 장애
- 규모 확장성
	- DB, 캐시 등 중요 컴포넌트를 개별적으로 늘릴 방법 없음
- 성능 병목
	- 시스템 과부하가 충분히 가능한 비즈니스
## 개략적인 설계안 2
> [! 개선 포인트]
> - 데이터베이스, 캐시를 알림 시스템의 주 서버 에서 분리
> - 알림 서버 스케일 아웃 가능하도록 변경
> - 메시지큐를 이용해 강한 결합을 끊는다

![[스크린샷 2024-12-03 오후 7.46.53.png]]
서비스 1~N, 제3자 제공 서비스, 단말은 설명에서 제외
- 알림 서버
	- 알림 서버는 아래의 기능을 제공
		- 스팸 방지를 위해 사내 서비스 또는 인증된 클라이언트만 사용 할 수 있음
		- 이메일, 전화번호 등의 기본적인 검증 수행
		- 알림에 포함시킬 데이터를 DB 에서 가져올 수 있어야 함
		- 알림 데이터를 메시지큐에 넣을 수 있어야 함
- 캐시
	- 아래의 데이터 캐시 가능해야 함
		- 사용자 정보
		- 단말 정보
		- 알림 템플릿
- DB
	- 사용자, 알림, 설정 등의 정보를 저장할 수 있어야 함
- 메시지 큐
	- 다량의 알림에도 안정적
	- 시스템 컴포넌트간 의존성 제거
	- 제3자 서비스 중 하나에서 장애가 발생 하더라도 전파 X
- 작업 서버
	- 메시지큐 에서 알림을 꺼내서 제 3자 서비스로 전달
```
POST https://api.example.com/v/sms/send
```
api 호출 시 전송할 데이터 사례:
```json
{
	"to": [
		{
			"user_id": 123456
		}
	],
	"from": {
		"email": "from_address@example.com"
	},
	"subject": "Hello, World!",
	"content": [
		{
			"type": "text/plain",
			"value": "Hello, World!"
		}
	]
}
```

# 3단계 : 상세 설계
## 안정성
### 데이터 손실 방지
어떤 상황에서도 알림은 소실되면 안됨
![[스크린샷 2024-12-03 오후 8.06.35.png]]
### 중복 전송 방지
- 분산 시스템 특성 상 가끔 같은 알림이 중복 전송 될 수 있음
	- ex: 이벤트 ID 검증하여 이전에 처리한 적 있는 이벤트인지 검사
## 고려사항
- 알림 템플릿
	- 하루에도 수백만건 알림 처리
	- 알림의 유사성을 고려하여 파라미터, 추적 링크 등의 간단한 수정 만으로도 알림이 완전해지도록 만듬
- 알림 설정
	- 사용자가 너무 많은 알림을 강제로 받을 경우 피곤함을 느낌.
	- 알림 설정의 다양화. 선택한 알림만 받을 수 있게 처리
- 전송률 제한
	- 알림의 빈도를 제한
	- 너무 많은 알람은 사용자에게 알림을 끈다는 선택지를 줌
- 재시도 방법
	- 제3자 서비스가 알림 전송에 실패하면 해당 알림을 재시도 큐에 저장
	- 반복적인 실패가 발생하면 개발자에게 통지
- 푸시 알림과 보안
	- 인증 되고 승인 된 클라이언트만 알림을 전송할 수 있도록 제한
- 큐 모니터링
	- 큐에 너무 많은 요청이 쌓이면 서버를 증설하는 등의 조치를 취해야 함
- 이벤트 추적
	- ![[스크린샷 2024-12-03 오후 8.20.40.png]]
고려사항들을 모두 적용 한 설계안
![[스크린샷 2024-12-03 오후 8.21.07.png]]

  