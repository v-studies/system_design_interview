![image](https://github.com/user-attachments/assets/c4b16705-8409-4c00-9f6f-fab1f38e8d55)## 채팅의 기본 기능과 프로토콜
채팅 서비스가 갖춰야 할 기본 기능은 아래와 같다.
- 클라이언트들로부터 메시지 수신
- 메시지 수신자 결정 및 전달
- 수신자가 접속 상태가 아닌 경우 접속할 때까지 보관

![image](https://github.com/user-attachments/assets/e73df7f0-a340-4b91-95c2-c11f51179d91)


채팅 서비스의 경우 어떤 통신 프로토콜을 사용할 것인지가 굉장히 중요한 요소이다.
위 그림에서는 클라이언트가 채팅 서비스에 HTTP 프로토콜로 연결한 다음 메시지를 보내어 수신자에게 해당 메시지를 전달하라고 알린다.

이때 keep-alive 헤더를 사용해 클라이언트-서버 사이의 연결을 끊지 않고 계속 유지하도록 하면 핸드셰이크 횟수를 줄일 수 있어 효율적이다. 하지만 메시지 수신 시나리오는 이것보다 복잡하고 서버에서 클라이언트로 임의 시점에 메시지를 보내는데 쉽게 쓰일 수 없는 문제가 존재한다. 따라서 이를 해결하기 위해 폴링, 롱 폴링, 웹소켓 등 다양한 기법들이 제안되어 왔다.


### 폴링
폴링 기법은 클라이언트가 주기적으로 서버에게 새 메시지가 있는지 확인하는 방법이다.
주기적으로 확인하는 방법이기 때문에 서버에서 답해줄 메시지가 없는 경우 서버 자원이 불필요하게 낭비된다.
![image](https://github.com/user-attachments/assets/a8345125-8ab9-47eb-b2db-663866667c65)


### 웹소켓
웹소켓은 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술이다.
![image](https://github.com/user-attachments/assets/94b199ce-97ca-4fbb-a32a-0f44b517d48d)
클라이언트가 웹소켓 연결을 시작하고, 한번 맺어진 연결은 양방향으로 이루어진다.
처음에는 HTTP 연결이지만 특정 핸드셰이크 절차를 거치면 웹소켓 연결로 변경된다.
또한, 웹소켓을 사용하면 메시지를 보낼 때나 받을 때 동일한 프로토콜을 사용할 수 있으므로 구현도 단순하고 직관적이다. 따라서 채팅 시스템을 설계할 때 굳이 HTTP 연결을 고집할 필요 없이 웹소켓을 사용하면 된다.


### 개략적 설계안
![image](https://github.com/user-attachments/assets/629a86bc-a654-4b9e-a39a-6f3400df096d)

실시간으로 메시지를 주고받기 위해 클라이언트는 채팅 서버와 웹소켓 연결을 끊지 않고 유지한다.

- 채팅 서버는 클라이언트 사이에서 메시지를 중계하는 역할을 담당한다.
- 접속 상태 서버는 사용자의 접속 여부를 관리한다.
- API 서버는 로그인, 회원가입 등 나머지 전부를 처리한다.
- 알림 서버는 푸시 알림을 담당한다.
- 키-값 저장소는 채팅 이력을 보관하고 사용자에게 이전 채팅 이력 정보 제공을 담당한다.



### 저장소
채팅 시스템이 다루는 데이터는 보통 두 가지다.

1. 사용자 프로필, 설정, 친구 목록과 같은 일반적인 데이터
2. 채팅 이력처럼 채팅 시스템에 고유한 데이터
우리는 이 두 개의 데이터 유형과 읽기/쓰기 연산 패턴을 이해하고 저장소를 선택해야 한다.

1번의 경우 데이터 안정성을 보장하는 관계형 데이터베이스가 적합하고
2번은 키-값 저장소와 같은 NoSQL이 유리하다.

채팅 이력 데이터의 양은 엄청나게 많고 최근에 주고받은 메시지가 가장 빈번하게 사용되며, 검색 기능이나 멘션 같은 기능도 잘 지원해야 한다. 키-값 저장소는 수평적 규모 확장이 쉽고, 데이터 접근 지연시간이 낮기 때문에 채팅 이력을 보관하는 저장소로 사용하기에 적합하다.



### 데이터 모델
#### 1:1 채팅을 위한 메시지 테이블
- [message_id], message_from, message_to, content, created_at
#### 그룹 채팅을 위한 메시지 테이블
- [channel_id, message_id], message_to, content, created_at


## 상세 설계 

### 서비스 탐색
앞서 잠깐 언급했듯 서비스 탐색은 클라이언트에게 가장 적합한 채팅 서버를 추천해준다.
주키퍼로 구현한 서비스 탐색 기능의 동작 방식은 다음과 같다.
![image](https://github.com/user-attachments/assets/614741f9-27c5-4bd9-a926-55b33fef2afe)
- 사용자가 시스템 로그인을 시도한다.
- 로드밸런서가 API 서버들 중 하나로 요청을 보낸다.
- API 서버가 인증 처리를 완료하면 서비스 탐색 기능이 동작하여 최적의 채팅 서버를 찾는다.
- 사용자는 최적의 채팅 서버로 선택된 채팅 서버 2와 웹소켓 연결을 맺는다.


### 메시지 전달 흐름
1:1 채팅 메시지 처리 흐름  

![image](https://github.com/user-attachments/assets/36360f37-1b17-4f49-b209-c7ef886cf41f)
- 사용자 A가 채팅 서버 1로 메시지 전송
- 채팅 서버 1은 ID 생성기를 사용해 메시지 ID를 결정
- 해당 메시지를 메시지 동기화 큐로 전송
- 메시지가 키-값 저장소에 보관됨
- 사용자 B가 접속 중인 경우 B가 사용 중인 채팅 서버로 메시지 전송, 사용자 B가 접속 중이 아니라면 푸시 알림 서버로 푸시 알림 메시지 전송
- 채팅 서버 2는 메시지를 사용자 B에게 전송. 사용자 B와 채팅 서버 2 사이에는 웹소켓이 연결되어 있으므로 그것을 이용


그룹 채팅 메시지 흐름

[송신]

![image](https://github.com/user-attachments/assets/3990c864-0056-4911-8ce2-fc59d23e77d1)

[수신]
![image](https://github.com/user-attachments/assets/1a73bf12-59c3-44d7-8e3c-ea76dc09f7a6)


https://steady-record.tistory.com/entry/Spring-WebSocket%EC%9C%BC%EB%A1%9C-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EC%B1%84%ED%8C%85-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0
