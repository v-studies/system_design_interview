
### 메세지 모델
- 일대일 모델
![image](https://github.com/user-attachments/assets/9f320959-5d32-4987-977d-a55c813e1783)


- 발행 - 구독 모델 
![image](https://github.com/user-attachments/assets/271b50b4-041a-42e2-8864-3a9ee87ad173)

### 토픽, 파티션, 브로커
- 파티션을 유지하는 서버는 보통 브로커(Broker)라 부른다. 
- 토픽에 보관해야 할 데이터 양이 많을 경우 -> 파티션 개수를 늘리면 된다. -> 각 토픽 파티션은 FIFO로 동작한다. -> 메세지에는 사용자 ID 같은 키를 붙일 수 있는데, 같은 키를 가진 모든 메세지는 같은 파티션으로 보내진다.


![image](https://github.com/user-attachments/assets/3d0922b4-9323-4130-a6aa-555ef8c46035)

 
### 푸시 vs 풀
- 브로커가 데이터를 소비자에게 보낼 것이냐 아니면 소비자가 브로커에게 가져갈 것인지 고민해야하는 부분이다.

 
##### 푸시 모델

- 장점 
  - 낮은 지연: 브로커는 메세지를 받는 즉시 소비자에게 보낼 수 있다.
- 단점
  - 소비자가 메세지를 처리하는 속도가 생산자가 메세지를 만드는 속도보다 느릴 경우, 소비자에게 큰 부하가 걸릴 가능성이 있다.
  - 생산자가 데이터 전송 속도를 좌우하므로, 소비자는 항상 그에 맞는 처리가 가능한 컴퓨팅 자원을 준비해두어야 한다.

##### 풀 모델
- 장점
  - 메세지를 소비하는 속도는 소비자가 알아서 결정한다. 
   - 소비자는 지난번 마지막으로 가져간 로그 위치 다음에 오는 메세지를 한 번에 가져갈 수 있다. 따라서 데이터의 공격적 일괄 처리에 더 적합하다.
- 단점
   - 브로커에 메시지가 없어도 소비자는 계속 데이터를 끌어가려 시도할 것이기 때문에, 소비자 측 컴퓨팅 자원이 낭비된다.
   - 해당 문제를 해결하기 위해 롱 풀링 모드를 지원한다.
 

### 소비자 재조정
- 어떤 소비자가 어떤 파티션을 책임지는지 다시 정하는 프로세스이다.
- 해당 절차는 코디네이터가 중요한 역할을 한다.
   - 코디네티어는 소비자 재조정을 위해 소비자들과 통신하는 브로커 노드이다.
   - 소비자로부터 오는 박동 메세지를 살피고 각 소비자의 파티션 내 오프셋 정보를 관리한다.
 
### 상태 저장소
